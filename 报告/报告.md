<center><h1>实训报告：项目二《升级版麦当劳网站》




## 一、项目背景

​		麦当劳是众人热爱的餐饮品牌，其美味食物带给了大家许多味蕾及心灵上的享受。它于1990年进入中国市场,始终坚持以高品质的食品、亲切友善的服务、清洁舒适的用餐环境和物超所值的用餐体验为每一位顾客提供最佳的用餐服务。

​		浏览麦当劳中国官网，这种简约、活力的设计也深深地感染着我们。为了表达我们对麦当劳的热爱，我们决定构建一个升级版的麦当劳网站，能让大家了解到麦当劳产品的同时，也能收获麦当劳带给我们的欢乐。为了弥补麦当劳中国官网无法在线点餐的缺点，我们将实现一个网上订餐功能；并且为了增加其趣味性，我们还将实现一个仅供娱乐的摇摇机页面，解决用户“选择困难症”的问题。



## 二、需求介绍

### 2.1  页面需求

* **广告页(首页)**：更好地宣传麦当劳，展示麦当劳的最新产品动态及节日活动；
* **餐品总览页**：让大家了解麦当劳餐品，展示麦当劳大部分可选购的餐品；
* **订餐页面**：增加网站功能性，可让用户自由选择餐品；
* **摇摇机页面**：增加网站趣味性，可供用户无聊时与之互动。



### 2.2  功能需求

<table>
	<tr>
	    <th>主模块</th>
	    <th>子模块</th>
	    <th>模块功能说明</th>  
	</tr >
	<tr >
	    <td rowspan="3">广告页(首页)</td>
	    <td>顶部导航栏</td>
	    <td>可跳转到各个主模块</td>
	</tr>
	<tr>
	    <td>广告部分</td>
	    <td>展示广告信息</td>
	</tr>
	<tr>
	    <td>底部栏</td>
	    <td>可供分享、跳转app下载等</td>
	</tr>
	<tr>
	    <td rowspan="5">餐品总览页</td>
	    <td>顶部导航栏</td>
	    <td>可跳转到各个主模块</td>
	</tr>
    <tr>
	    <td>餐品导航</td>
	    <td>可跳转至不同餐品类型的餐品概览</td>
	</tr>
    <tr>
	    <td>餐品介绍</td>
	    <td>展示该类型的所有餐品名及图片</td>
	</tr>
    <tr>
	    <td>广告部分</td>
	    <td>视情况在餐品介绍部分下添加广告信息</td>
	</tr>
    <tr>
	    <td>底部栏</td>
	    <td>可供分享、跳转app下载等</td>
	</tr>
	<tr>
	    <td rowspan="9">网上订餐页</td>
	    <td>侧边导航栏</td>
	    <td>可返回首页，导航到不同餐品类型的餐品订购</td>
	</tr>
	<tr>
	    <td rowspan="2">登录</td>
        <td>跳转登录界面，供用户登录</td>
	</tr>
    <tr>
        <td>用户登录后，可供用户退出</td>
    </tr>
    <tr>
	    <td>餐车</td>
	    <td>在用户登录情况下，跳转餐车功能</td>
	</tr>
    <tr>
	    <td>餐车详情</td>
	    <td>展示用户选购餐品，可增删改；跳转下单或返回订餐</td>
	</tr>
    <tr>
	    <td>下单</td>
	    <td>展示用户下单的餐品及数量，金额总金额等；跳转订单确认或返回餐车</td>
	</tr>
    <tr>
	    <td>订单确认</td>
	    <td>展示订单，供用户选择地址，增删改地址；跳转结账</td>
	</tr>
    <tr>
	    <td>结账</td>
	    <td>展示订单，供用户选择支付方式并支付</td>
	</tr>
    <tr>
	    <td>餐品</td>
	    <td>按餐品类型分类，展示名字、描述、价格，供用户添加至餐车</td>
	</tr>
	<tr >
	    <td rowspan="3">摇摇机页面</td>
	    <td>顶部导航栏</td>
	    <td>可跳转到各个主模块</td>
	</tr>
    <tr>
	    <td>摇摇机</td>
	    <td>类似抽奖机，点击后随机转动出汉堡、小食甜品、饮品图案各一份</td>
	</tr>
    <tr>
	    <td>底部栏</td>
	    <td>可供分享、跳转app下载等</td>
	</tr>
</table>



### 2.3  接口需求

具体接口实现，依据实践项目开发变更。

1. 登录

    请求地址：`/user/login`，请求方式：Post

    请求参数：`{user, request, response}`

2. 登出

    请求地址：`/user/logout`，请求方式：Post

    请求参数：`{user}`

3. 注册

    请求地址：`/user/register`，请求方式：Post

    请求参数：`{user}`

4. 获取用户信息

    请求地址：`/user/token`，请求方式：Get

    请求参数：`{token, request, response}`

5. 获取商品列表

    请求地址：`/product`，请求方式：Get

    请求参数：无

6. 获取购物车信息

    请求地址：`/cart/user/{userId}`，请求方式：Get

    请求参数：`{userId}`

7. 添加商品到购物车

    请求地址：`/cart/product/user/{productId}/{userId}`，请求方式：Post

    请求参数：`{productId, userId}`

8. 修改购物车商品数量

    请求地址：`/cart/user/num/{cartId}/{userId}/{num}`，请求方式：Put

    请求参数：`{cartId, userId, num}`

9. 删除购物车商品

    请求地址：`/cart/user/{cartId}/{userId}`，请求方式：Delete

    请求参数：`{cartId, userId}`

10. 下单

    请求地址：`/order`，请求方式：Post

    请求参数：`{cartVoList cookie}`

11. 获取订单信息

    请求地址：`/order`，请求方式：Get

    请求参数：`{cookie}`



## 三、关键技术简介

本项目前后端分离：
		前端基于`Vue2`+`Vue-router`+`Vuex`+`Axios`+`Element-ui`+`Mock` 实现；
		后端基于`SpringBoot`+`Rest`+`Lombok`+`MyBatis-Plus`+`MySQL`+`Redis`+`MD5` 实现。

### 3.1  前端

#### (1) Vue2

​		Vue.js 是一套构建用户界面的**渐进式框架**。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。其中 Vue 2.0 是我们选择的 Vue 版本，目前国内的主流版本，较 3.0 版本更易上手。

#### (2) Vue-router

​		用于 Vue 项目的**路由插件**。Vue 的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。我们用于页面跳转、顶部导航栏支持等。使用 Vue-cli 构建项目时，可选择用路由来引用依赖。

#### (3) Vuex

​		Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式 + 库**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。我们用于保存登录状态、购物车状态等。

#### (4) Axios

​		Axios 是一个基于 promise 的**网络请求库**，类似于 jQuery 的 Ajax，用于 HTTP 请求。它可以用于浏览器和 node.js。它有许多特性，包括：拦截请求和响应，转换请求数据和响应数据，取消请求，自动转换 JSON 数据等。我们将其简单封装，用来调用接口。

#### (5) Element-UI

​		Element-UI 是基于 Vue 实现的一套不依赖业务的 **UI 组件库**，提供了丰富的 PC 端组件，减少开发者对常用组件的封装，降低了开发的难易程度。

#### (6) Mock

​		Mock.js 是一款模拟数据生成器，可以生成随机或指定数据，拦截 Ajax 请求。在前后端分离的项目开发中，前端常常用 Mock 来模拟数据，测试接口的使用，以便在后端接口完成前，实现前端页面功能。



### 3.2  后端

#### (1) Spring Boot

​		我们使用Spring Boot作为一种高效的javaweb后端框架。 Spring Boot 简化了 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，实现了IOC容器的自动装配，从而使开发人员不再需要定义样板化的配置。

#### (2) Rest风格

​		我们使用Rest(Representational State Transfer)软件架构风格，对资源的操作url统一为/[资源名]，不同操作方式用HTTP请求方式动词来区分。降低了开发的复杂性，提高了系统的可伸缩性。

#### (3) Lombok

​		Lombok项目是一个 java 库，它使用注解辅助生成类的方法，它可以自动插入到编辑器和构建工具中，增强 java 的性能。不需要再写 getter、setter 或equals 方法，只需要一个注解。

#### (4) MyBatis-Plus

​		MyBatis 是一款的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs映射成数据库中的记录。

​		MyBatis-Plus是一个基于 MyBatis 的增强工具，可以看作是对 MyBatis 的再一次封装，封装了JDBC，使得连接数据库的java程序与SQL语句分离。对于单表的 CRUD 操作，调用 MyBatis-Plus 所提供的 API 就能够轻松实现，此外还提供了各种查询方式、分页等行为。

#### (5) MySQL

​		一种流行的关系数据库。我们将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。

#### (6) Redis

​		一种内存中的数据结构存储系统，高性能的key-value数据库，支持存储的value类型很多，常用作sql数据库的缓存。在此项目用作cookie管理和身份验证。

#### (7) MD5加密

​		MD5信息摘要算法，一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。



## 四、系统设计

### 4.1  实现功能

### 前端

* 登录
* 各页面跳转
* 一键返回页面顶部
* 广告页展示
* 所有餐品展示
* 订餐餐品展示及加购
* 餐车内加购餐品增删改
* 选购餐品下单
* 订单选择地址确认
* 结账支付
* 摇摇机页面



### 后端

* 登录、注册、判断用户名是否存在、获取用户信息
* 获取类别
* 获取产品照片id、根据id获取产品、根据展示页数获得产品。
* 获取购物车信息、添加商品到购物车、修改购物车商品数量、删除购物车商品
* 获取收藏信息、收藏商品、取消收藏商品、
* 获取首页轮播图
* 商品下单



### 4.2  项目结构

#### 前端：Vue2 常规项目结构

使用Vue-cli脚手架搭建的Vue2项目结构

```c
McDonaldWeb
├─ public
   ├─ json // 模拟数据
   └─ images // 图片资源(大图片放public/images，小图片放src/assets)
├─ src
   ├─ api // 接口
      ├─ http.js // axios封装
      ├─ index.js // api接口统一出口
      ├─ base.js // api接口域名管理
      └─ mall.js // 商城模块api映射配置
   ├─ assets // css、iconfont、小图标
   ├─ components // 组件库
   ├─ config // 配置：环境变量
   ├─ mock // mock模拟数据
   ├─ newPages // 页面
   ├─ pages // 页面
   ├─ router // 路由
   ├─ storage // 本地数据存储：sessionStorage、localStorage
   ├─ store // vuex
   └─ util // 工具js库
├─ vue.config.js // 配置文件
├─ package.json // 项目核心配置记录，可查看当前安装依赖的版本号
├─ .gitignore //配置git可忽略的文件
```



##### 资源说明

* public 静态资源

    * `public/font` 字体文件

    * `public/images` 图片文件
    * 图片资源(建议：大图片放public/images，小图片放src/assets)
        
    * 图片能够放后端或者云存储的别放前端，减少包体积和优化加载速度 。
        
    * 图片如果是复用的图片，不属于某个页面独有的图片，直接放此目录。
        
    * 图片如果属于某个功能模块独有的，需要建立一个和模块名称同名的文件夹，再存于文件夹下。如：`public/img/pay` 支付模块的图片。
    
* assets 静态资源
    * `assets/scss` css文件

* store vuex 缓存

    我们采用分模块来管理各个vuex子模块，便于项目的维护和整合。

    * `index.js` 此文件是入口文件，方便整合和引入vuex模块
    * `modules/user.js`  此文件是用户信息相关vuex模块



##### 组件说明

- 组件命名规范

  * 组件名称：大驼峰，如：GoodsList.vue
  * 组件文件：组件名称/组件名称.vue，一个组件对应一个文件夹，该文件夹下可以有多个类型的文件（如：js、img、css等）。如：`goodsList/GoodsList.vue`

- 组件存放规范

  * 自定义公共复用组件存放为：`components/Com*/Com*.vue`这里存放自定义复用组件，方便开发和复用、共享。避免去uni-ui中直接修改，因为后面uni官方组件升级后会导致之前的自定义代码丢失。
  * 自定义非公共组件存放到：`当前页/组件文件`,如：首页的广告组件，`index/childComps/IndexAdv.vue`
    因为有的页面组件，自定义或者抽离的组件，也许其他页面根部就不会复用到，只是为了让主页面代码简洁和便于维护，那么这些组件，应该直接放到当前页下的`childComps`文件夹中，独立维护。

- 组件说明规范
  每个自定义组件在组件代码的`<script>`标签内的第一行备注：组件名称、组件描述、开发人员、组件参数等。

  ```vue
  <script>
     /*
     * LoadMore 加载更多
     * @description 用于列表中，做滚动加载使用，展示 loading 的各种状态
     * @author AuKeeWa
     * @property {String} status = [more|loading|noMore] loading 的状态
     * 	@value more loading 前
     * 	@value loading loading 中
     * 	@value noMore 没有更多了
     * @property {Number} iconSize 指定图标大小
     */
  
  </script>
  ```

##### 命名规范

* 文件夹名称：小驼峰
* js文件名称：小驼峰
* vue文件名称：大驼峰



#### 后端：Spring MVC的经典分层架构

```c
 mcd
|--controller
   |--CarouselController
   |--CategoryController
   |--CollectController
   |--OrderController
   |--ProductController
   |--ProductPictureController
   |--ShoppingCartController
   |--UserController
|--exception // 异常类
   |--ExceptionEnum
   |--MDException
   |--XmException
   |--XmExceptionHandler
|--mapper
   |--CarouselMapper
   |--CategoryMapper
   |--CollectMapper
   |--OrderMapper
   |--ProductMapper
   |--ProductPictureMapper
   |--ShoppingCartMapper
   |--UserMapper
|--pojo
   |--Carousel //轮播图
   |--Category // 目录
   |--Collect //收藏
   |--Order //下单
   |--Product // 产品的相关信息
   |--ProductPicture // 产品图片
   |--ShoppingCart //购物车
   |--User // 用户账号密码
|--service
   |--CarouselService
   |--CategoryService
   |--CollectService
   |--OrderService
   |--ProductService
   |--ProductPictureService
   |--ShoppingCartService
   |--UserService
|--utils // 工具类
   |--BeanUtil
   |--CookieUtil
   |--IdWorker
   |--MD5Util
   |--ResultMessage
|--vo
   |--CartVo
   |--OrderVo
|--Application
```

* controller控制器层，负责前后端交互：从HTTP请求中获取信息，提取参数，并将其分发给不同的处理服务（service层），并向前端返回service层处理后的数据（JSON数据或者ModelAndView对象）。
* service业务层，存放业务逻辑处理，前接controller，后接mapper。包括接口声明、接口继承、接口实现。
* mapper数据层，数据库的接口。
* pojo，实体类，与数据库的表相对应。
* 其他，utils内定义了一系列用到的工具类，vo视图层在返回前端前对数据进行最后的适应性包装。

![1673617146837](报告.assets/1673617146837.png)



### 4.3  项目本地部署

#### 前端

```xml
所需环境：Node.js + Vue + Vue-cli
运行流程：
1. 克隆项目
git clone https://github.com/AuKeeWa/McDonaldWeb.git

2. 安装项目依赖
cd vue-store
npm install

3. 开发项目：编译和热重载
npm run serve

4. 部署项目：编译和打包
npm run build
```



#### 后端

```xml
所需环境：Java17 + SpringBoot
所需依赖：<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.7.5</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.example</groupId>
    <artifactId>demo2</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>demo2</name>
    <description>Demo project for Spring Boot</description>
    <properties>
        <java.version>17</java.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-jdbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-thymeleaf</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.mybatis.spring.boot</groupId>
            <artifactId>mybatis-spring-boot-starter</artifactId>
            <version>2.2.2</version>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
        </dependency>
        <dependency>
            <groupId>tk.mybatis</groupId>
            <artifactId>mapper-spring-boot-starter</artifactId>
            <version>2.0.2</version>
        </dependency>
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
            <version>3.9</version>
        </dependency>
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>1.7.26</version>
            <scope>compile</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
运行流程：
运行 Application.java 文件
```



## 五、功能模块介绍

### 5.1  前端

项目地址：https://github.com/AuKeeWa/McDonaldWeb

#### 主要页面展示

##### ① 首页(广告页)

###### 顶部导航栏

![NavigationBar](报告.assets/NavigationBar.png)

![Index](报告.assets/Index.png)

##### ② 餐品总览

![AllProduct-1](报告.assets/AllProduct-1.png)

![AllProduct-2](报告.assets/AllProduct-2.png)

![AllProduct-3](报告.assets/AllProduct-3.png)

![AllProduct-4](报告.assets/AllProduct-4.png)

![AllProduct-5](报告.assets/AllProduct-5.png)

![AllProduct-6](报告.assets/AllProduct-6.png)

##### ③ 网上订餐

![Menu](报告.assets/Menu.png)

![Login](报告.assets/Login.png)

![Cart](报告.assets/Cart.png)

![OrderConfirm](报告.assets/OrderConfirm.png)

![AddressChange](报告.assets/AddressChange.png)

![OrderPay](报告.assets/OrderPay.png)

![image-20230115003621570](报告.assets/image-20230115003621570.png)

![Alipay](报告.assets/Alipay.png)

##### ④ 外星页面(摇摇机页面)

![Alien](报告.assets/Alien.png)

#### 部分代码展示

##### ① 餐品总览 

AllProduct.vue ：Script部分

```javascript
<script>
export default {
  name: 'product',
  data() {
    return {
      showSlide: '', //控制动画效果
      product: {}, //商品信息
      activeName: 'first',
    };
  },
  methods: {
    handleClick(tab, event) {

      console.log({ tab }, { event });
    },
    // 打开视频
    openVideo() {
      this.showSlide = 'slideDown';
    },
    // 关闭视频
    closeVideo() {
      this.showSlide = 'slideUp';
      setTimeout(() => {
        this.showSlide = '';
      }, 600);
    }
  }
};
</script>
```



##### ② 网上订餐

Menu.vue ：Script部分

```javascript
<script>
import { mapState } from 'vuex';
export default {
    name: 'index',
    data() {
        return {
            active: 0   //激活的导航索引
        }
    },
    mounted() {
        window.addEventListener('scroll', this.onScroll, false);
    },
    destroy(){
        window.removeEventListener('scroll', this.onScroll);
    },
    computed: {
    // 获取store中state值
        ...mapState(['username', 'cartCount'])
    },
    methods: {
        // 登录
        goLogin() {
            this.$router.push('/login');
        },
        // 退出
        goLogout() {
            this.$api.mall.logout().then(() => {
                this.$message.success('退出成功');
                // 清除用户ID
                this.$cookie.set('userId', '', { expires: '-1' });
                // 清除用户名
                this.$store.dispatch('saveUserName', '');
                // 清空购物车数量
                this.$store.dispatch('saveCartCount', 0);
            });
        },
        // 加入购物车
        addCart(id) {
            if(!this.username){
                this.$message.warning('请先登录！');
                return;
            }
            let params = {
                productId: id,
                selected: true
            };
            this.$api.mall.addCart(params).then((res = { cartProductVoList: 0 }) => {
                this.$store.dispatch('saveCartCount', res.cartProductVoList.length + 1);
                this.$message.success('添加成功');
            });
        },
        // 去购物车
        goCart() {
            if(!this.username){
                this.$message.warning('请先登录！');
                return;
            }
            this.$router.push('/cart');
        },
        goToIndex() {
            this.$router.push('/index');
        },
        onScroll(){
            // 获取所有锚点元素
            const navContents = document.querySelectorAll('.CaName')
            // 所有锚点元素的 offsetTop
            const offsetTopArr = []
            navContents.forEach(item => {
                offsetTopArr.push(item.offsetTop)
            })
            // 获取当前文档流的 scrollTop
            const scrollTop = document.documentElement.scrollTop || document.body.scrollTop
            // 定义当前点亮的导航下标
            let navIndex = 0
            for (let n = 0; n < offsetTopArr.length; n++) {
                // 如果 scrollTop 大于等于第n个元素的 offsetTop 则说明 n-1 的内容已经完全不可见
                // 那么此时导航索引就应该是n了
                if (scrollTop + 150 >= offsetTopArr[n]) {
                    navIndex = n
                }
            }
            this.active = navIndex
        },
        // 跳转到指定索引的元素
        scrollTo(index) {
            // 获取目标的 offsetTop
            // css选择器是从 1 开始计数，我们是从 0 开始，所以要 +1
            const targetOffsetTop = document.querySelector(`.CaName:nth-child(${index + 1})`).offsetTop
            // 获取当前 offsetTop
            let scrollTop = document.documentElement.scrollTop || document.body.scrollTop
            // 定义一次跳 50 个像素，数字越大跳得越快，但是会有掉帧得感觉，步子迈大了会扯到蛋
            const STEP = 50
            // 判断是往下滑还是往上滑
            if (scrollTop > targetOffsetTop) {
                // 往上滑
                smoothUp()
            } else {
                // 往下滑
                smoothDown()
            }
            // 定义往下滑函数
            function smoothDown() {
                // 如果当前 scrollTop 小于 targetOffsetTop 说明视口还没滑到指定位置
                if (scrollTop < targetOffsetTop) {
                    // 如果和目标相差距离大于等于 STEP 就跳 STEP
                    // 否则直接跳到目标点，目标是为了防止跳过了。
                    if (targetOffsetTop - scrollTop >= STEP) {
                        scrollTop += STEP
                    }
                    else {
                        console.log(scrollTop)
                        console.log(targetOffsetTop)
                        scrollTop = targetOffsetTop
                    }
                    document.body.scrollTop = scrollTop+1
                    document.documentElement.scrollTop = scrollTop+1
                    // 关于 requestAnimationFrame 可以自己查一下，在这种场景下，相比 setInterval 性价比更高
                    requestAnimationFrame(smoothDown)
                }else{
                    console.log('else')
                }
            }
            // 定义往上滑函数
            function smoothUp() {
                if (scrollTop > targetOffsetTop) {
                    if (scrollTop - targetOffsetTop >= STEP) {
                        scrollTop -= STEP
                    } else {
                        scrollTop = targetOffsetTop
                    }
                    document.body.scrollTop = scrollTop+1
                    document.documentElement.scrollTop = scrollTop+1
                    requestAnimationFrame(smoothUp)
                }
            }
        },
        goToAnchor(selector) {
            this.$el.querySelector(selector).scrollIntoView();
        }

    }
};
</script>
```



##### ③ 外星页面(摇摇机页面)

Alien.vue ：Script部分

```javascript
<script>
    const next =
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.oRequestAnimationFrame ||

    function (cb) {
        window.setTimeout(cb, 10000 / 60);
    };

    export default {
        data() {
            return {
                slots: [
                {
                    title: "Burger",
                    items: [
                        require("../../public/images/dishes/burger/01.png"),
                        require("../../public/images/dishes/burger/02.png"),
                        require("../../public/images/dishes/burger/03.png"),
                        require("../../public/images/dishes/burger/04.png"),
                        require("../../public/images/dishes/burger/05.png"),
                        require("../../public/images/dishes/burger/06.png"),
                        require("../../public/images/dishes/burger/07.png"),
                        require("../../public/images/dishes/burger/08.png"),
                        require("../../public/images/dishes/burger/09.png"),
                        require("../../public/images/dishes/burger/10.png"),
                        require("../../public/images/dishes/burger/11.png"),
                        require("../../public/images/dishes/burger/12.png"),
                        require("../../public/images/dishes/burger/13.png"),
                        require("../../public/images/dishes/burger/14.png"),
                        require("../../public/images/dishes/burger/15.png"),
                    ],
                },
                {
                    title: "Snack",
                    items: [
                        require("../../public/images/dishes/snacks/01.png"),
                        require("../../public/images/dishes/snacks/02.png"),
                        require("../../public/images/dishes/snacks/03.png"),
                        require("../../public/images/dishes/snacks/04.png"),
                        require("../../public/images/dishes/snacks/05.png"),
                        require("../../public/images/dishes/snacks/06.png"),
                        require("../../public/images/dishes/snacks/07.png"),
                        require("../../public/images/dishes/snacks/08.png"),
                        require("../../public/images/dishes/snacks/09.png"),
                        require("../../public/images/dishes/snacks/10.png"),
                    ],
                },
                {
                    title: "Drink",
                    items: [
                        require("../../public/images/dishes/beverage/01.png"),
                        require("../../public/images/dishes/beverage/02.png"),
                        require("../../public/images/dishes/beverage/04.png"),
                        require("../../public/images/dishes/beverage/08.png"),
                        require("../../public/images/dishes/beverage/12.png"),
                        require("../../public/images/dishes/beverage/13.png"),
                    ],
                },
                ],

                opts: null,
                startedAt: null,
                fontSize: null,
            };
        },

        mounted() {
            this.$nextTick(() => {
                this.fontSize = this.getFont();
            });
        },
        methods: {
            start() {
                if (this.opts) {
                    return;
                }
                let height = 200;    //图片高度
                this.opts = this.slots.map((data, i) => {
                    const slot = this.$refs.slots[i]; // 读取每一列
                    const choice = Math.floor(Math.random() * data.items.length); // 获取每一列的长度
                    const opts = {
                        el: slot, //指向奖项元素的父级来控制控制滚动速度;
                        finalPos: choice * height, // height 为每一个奖品滚动标签的高度;
                        // finalPos: (choice-choice+1) * height,
                        startOffset:720 + Math.random() * 720 + i * 720, // 影响转的圈数
                        height: data.items.length * height,
                        duration: 3000 + i * 640, // 动画时常
                        isFinished: false, // 是否已经停止了
                    };
                    return opts;
                });

                next(this.animate); // 启动动画
            },
            animate: function (timestamp) {
                // timestamp当前的方法持续的毫秒数
                if (this.startedAt == null) {
                    this.startedAt = timestamp; // 动画初始时间
                }
                const timeDiff = timestamp - this.startedAt; //动画持续的时间
                this.opts.forEach((opt) => {
                    if (opt.isFinished) {
                        return;
                    }
                    const timeRemaining = Math.max(opt.duration - timeDiff, 0); // 总的持续时间 - 动画持续时间 = 剩下的时间,0表示结束
                    const power = 3;
                    const offset = (Math.pow(timeRemaining, power) / Math.pow(opt.duration, power)) * opt.startOffset;
                    const pos = -1 * Math.floor((offset + opt.finalPos) % opt.height);
                    console.log(offset,opt.finalPos,opt.height);
                    opt.el.style.transform = "translateY(" + pos + "px)";
                    if (timeDiff > opt.duration) {
                        opt.isFinished = true;
                    }
                });
                if (this.opts.every((o) => o.isFinished)) {
                    // 判断时候所有的isFinished都是true
                    this.opts = null;
                    this.startedAt = null;
                } else {
                    next(this.animate);
                }
            },
            getFont() {
                var ration = 2;
                var params = {
                    defaultFontSize: 20,
                    designWidth: 750,
                };
                var clientWidth = document.documentElement.clientWidth;
                ration = clientWidth / params.designWidth;
                return ration * params.defaultFontSize;
            },
        },
    };
</script>
```



##### ④ 登录

Login.vue ：Script部分

```javascript
<script>
import NavFooter from '@/components/NavFooter.vue';
import { mapActions } from "vuex";
export default {
  name: 'login',
  components: { NavFooter },
  data() {
    return {
      username: '', // admin1/admin1 和 jack/jack
      password: '',
      userId: ''
    };
  },
  methods: {
    ...mapActions(['saveUserName']),
    login() {
      let { username, password } = this;
      this.$api.mall
        .login({
          username,
          password
        })
        .then((res) => {
          // vue-cookie插件：用户id保存7天
          this.$cookie.set('userId', res.id, { expires: 'Session' });
          // vuex：保存用户名
          this.saveUserName(res.username);
          this.$router.push({
            name: 'menu',
            params: {
              from: 'login'
            }
          });
        });
    },
    register() {
      this.$api.mall.register({
        username: 'admin1',
        password: 'admin1',
        email: 'admin1@qq.com'
      })
        .then(() => {
          this.$message.success('恭喜您，注册成功！');
        })
    }
  }
};
</script>
```



##### ⑤ 餐车

Cart.vue ：Script部分

```javascript
<script>
import OrderHeader from '@/components/OrderHeader';
import NavFooter from '@/components/NavFooter';
export default {
  name: 'cart',
  components: {
    OrderHeader,
    NavFooter
  },
  data() {
    return {
      list: [], //餐品列表
      allChecked: false, //是否全选
      cartTotalPrice: 0, //餐品总金额
      checkedNum: 0 //选中餐品数量
    };
  },
  mounted() {
    this.getCartList();
  },
  methods: {
    // 获取餐车列表
    getCartList() {
      this.$api.mall.getCart().then((res) => {
        this.renderData(res);
      });
    },
    // 更新餐车数量和购物车单选状态
    updateCart(item, type) {
      let quantity = item.quantity,
        selected = item.productSelected;
      if (type == '-') {
        if (quantity == 1) {
          this.$message.warning('餐品至少保留一件');
          return;
        }
        --quantity;
      } else if (type == '+') {
        if (quantity > item.productStock) {
          this.$message.warning('购买数量不能超过库存数量');
          return;
        }
        ++quantity;
      } else {
        selected = !item.productSelected;
      }
      let params ={
        productId: item.productId,
        quantity: quantity,
        selected: selected
      };
      this.$api.mall
        .updateCart(params)
        .then((res) => {
          this.renderData(res);
        });
    },
    // 删除餐车商品
    delProduct(item) {
      this.$api.mall.deleteCart({id:item.productId}).then((res) => {
        this.$message.success('删除成功');
        this.renderData(res);
      })
    },
    // 控制全选功能
    toggleAll() {
      this.$api.mall.allCheckCart({allchecked:this.allChecked}).then((res) => {
          this.renderData(res);
      })
    },
    // 公共赋值
    renderData(res) {
      this.list = res.cartProductVoList || [];
      this.allChecked = res.selectedAll;
      this.cartTotalPrice = res.cartTotalPrice;
      this.checkedNum = this.list.filter((item) => item.productSelected).length;
    },
    // 餐车下单
    order() {
      let isCheck = this.list.every((item) => !item.productSelected);
      if (isCheck) {
        this.$message.warning('请选择一款餐品');
      } else {
        this.$router.push('/order/confirm');
      }
    }
  }
};
</script>
```





### 5.2  后端

项目地址：https://gitee.com/kidrem/springboot_-mc-donald/tree/master

#### 核心代码展示

##### ① 登录注册

下面方法实现了用户的登录注册功能。

```java
public User login(User user) {
        user.setPassword(MD5Util.MD5Encode(user.getPassword() + "", "UTF-8"));
        User one = userMapper.selectOne(user);
        if (one == null) {
            throw new MDException(ExceptionEnum.GET_USER_NOT_FOUND);
        }
        return one;
    }

    public void register(User user) {
        User one = new User();
        one.setUsername(user.getUsername());
        // 先去看看用户名是否重复
        if (userMapper.selectCount(one) == 1) {
            // 用户名已存在
            throw new MDException(ExceptionEnum.SAVE_USER_REUSE);
        }
        // 使用md5对密码进行加密
        user.setPassword(MD5Util.MD5Encode(user.getPassword() + "", "UTF-8"));
        // 存入数据库
        try {
            userMapper.insert(user);
        } catch (Exception e) {
            e.printStackTrace();
            throw new MDException(ExceptionEnum.SAVE_USER_ERROR);
        }
    }
```

##### ② 商品收藏

controller.CollectController.java中实现了获取收藏信息、收藏商品、取消收藏商品的功能。

```java
@Service
public class CollectService {

    @Autowired
    private CollectMapper collectMapper;

    @Transactional
    public void addCollect(String userId, String productId) {
        Collect collect = new Collect();
        collect.setUserId(Integer.parseInt(userId));
        collect.setProductId(Integer.parseInt(productId));
        // 先看看是否数据库中已存在
        Collect one = collectMapper.selectOne(collect);
        if (one != null) {
            throw new XmException(ExceptionEnum.SAVE_COLLECT_REUSE);
        }
        // 不存在，添加收藏
        collect.setCollectTime(new Date().getTime());
        int count = collectMapper.insert(collect);
        if (count != 1) {
            throw new XmException(ExceptionEnum.SAVE_COLLECT_ERROR);
        }
    }

    public List<Product> getCollect(String userId) {
        List<Product> list = null;
        try {
            list = collectMapper.getCollect(userId);
            if (ArrayUtils.isEmpty(list.toArray())) {
                throw new XmException(ExceptionEnum.GET_COLLECT_NOT_FOUND);
            }
        } catch (XmException e) {
            e.printStackTrace();
            throw new XmException(ExceptionEnum.GET_COLLECT_ERROR);
        }
        return list;
    }

    public void deleteCollect(String userId, String productId) {
        Collect collect = new Collect();
        collect.setUserId(Integer.parseInt(userId));
        collect.setProductId(Integer.parseInt(productId));
        try {
            int count = collectMapper.delete(collect);
            if (count != 1) {
                throw new XmException(ExceptionEnum.DELETE_COLLECT_ERROR);
            }
        } catch (XmException e) {
            e.printStackTrace();
            throw new XmException(ExceptionEnum.DELETE_COLLECT_ERROR);
        }
    }
}
```

##### ③ 商品下单

controller.OrderController.java中实现了商品下单的功能。

```java
@Service
public class OrderService {

    @Autowired
    private IdWorker idWorker;
    @Autowired
    private RedisTemplate redisTemplate;
    @Autowired
    private OrderMapper orderMapper;
    @Autowired
    private ShoppingCartMapper cartMapper;
    @Autowired
    private ProductMapper productMapper;


    @Transactional
    public void addOrder(List<CartVo> cartVoList, Integer userId) {
        // 先添加订单
        String orderId = idWorker.nextId() + ""; // 订单id
        long time = new Date().getTime(); // 订单生成时间
        for (CartVo cartVo : cartVoList) {
            Order order = new Order();
            order.setOrderId(orderId);
            order.setOrderTime(time);
            order.setProductNum(cartVo.getNum());
            order.setProductId(cartVo.getProductId());
            order.setProductPrice(cartVo.getPrice());
            order.setUserId(userId);
            try {
                orderMapper.insert(order);
            } catch (Exception e) {
                e.printStackTrace();
                throw new XmException(ExceptionEnum.ADD_ORDER_ERROR);
            }
            // 减去商品库存,记录卖出商品数量
            Product product = productMapper.selectByPrimaryKey(cartVo.getProductId());
            product.setProductNum(product.getProductNum() - cartVo.getNum());
            product.setProductSales(product.getProductSales() + cartVo.getNum());
            productMapper.updateByPrimaryKey(product);
        }
        // 删除购物车
        ShoppingCart cart = new ShoppingCart();
        cart.setUserId(userId);
        try {
            int count = cartMapper.delete(cart);
            if (count == 0) {
                throw new XmException(ExceptionEnum.ADD_ORDER_ERROR);
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new XmException(ExceptionEnum.ADD_ORDER_ERROR);
        }

    }

    public List<List<OrderVo>> getOrder(Integer userId) {
        List<OrderVo> list = null;
        ArrayList<List<OrderVo>> ret = new ArrayList<>();
        try {
            list = orderMapper.getOrderVoByUserId(userId);
            if (ArrayUtils.isEmpty(list.toArray())) {
                throw new XmException(ExceptionEnum.GET_ORDER_NOT_FOUND);
            }
            // 将同一个订单放在一组
            Map<String, List<OrderVo>> collect = list.stream().collect(Collectors.groupingBy(Order::getOrderId));
            Collection<List<OrderVo>> values = collect.values();
            ret.addAll(values);
        } catch (XmException e) {
            e.printStackTrace();
            throw new XmException(ExceptionEnum.GET_ORDER_ERROR);
        }
        return ret;
    }

}
```

##### ④ 订单ID自增长

utils.IdWorker.java中实现了分布式自增长的订单ID。

原理结构如下，分别用一个0表示一位，用-分割开部分的作用：

1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000

在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间，然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识），然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。

这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分），并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。

```java
public class IdWorker {
    // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动）
    private final static long twepoch = 1288834974657L;
    // 机器标识位数
    private final static long workerIdBits = 5L;
    // 数据中心标识位数
    private final static long datacenterIdBits = 5L;
    // 机器ID最大值
    private final static long maxWorkerId = -1L ^ (-1L << workerIdBits);
    // 数据中心ID最大值
    private final static long maxDatacenterId = -1L ^ (-1L << datacenterIdBits);
    // 毫秒内自增位
    private final static long sequenceBits = 12L;
    // 机器ID偏左移12位
    private final static long workerIdShift = sequenceBits;
    // 数据中心ID左移17位
    private final static long datacenterIdShift = sequenceBits + workerIdBits;
    // 时间毫秒左移22位
    private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;

    private final static long sequenceMask = -1L ^ (-1L << sequenceBits);
    /* 上次生产id时间戳 */
    private static long lastTimestamp = -1L;
    // 0，并发控制
    private long sequence = 0L;

    private final long workerId;
    // 数据标识id部分
    private final long datacenterId;

    public IdWorker(){
        this.datacenterId = getDatacenterId(maxDatacenterId);
        this.workerId = getMaxWorkerId(datacenterId, maxWorkerId);
    }
    /**
     * @param workerId
     *            工作机器ID
     * @param datacenterId
     *            序列号
     */
    public IdWorker(long workerId, long datacenterId) {
        if (workerId > maxWorkerId || workerId < 0) {
            throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId));
        }
        if (datacenterId > maxDatacenterId || datacenterId < 0) {
            throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId));
        }
        this.workerId = workerId;
        this.datacenterId = datacenterId;
    }
    /**
     * 获取下一个ID
     *
     * @return
     */
    public synchronized long nextId() {
        long timestamp = timeGen();
        if (timestamp < lastTimestamp) {
            throw new RuntimeException(String.format("Clock moved backwards.  Refusing to generate id for %d milliseconds", lastTimestamp - timestamp));
        }

        if (lastTimestamp == timestamp) {
            // 当前毫秒内，则+1
            sequence = (sequence + 1) & sequenceMask;
            if (sequence == 0) {
                // 当前毫秒内计数满了，则等待下一秒
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0L;
        }
        lastTimestamp = timestamp;
        // ID偏移组合生成最终的ID，并返回ID
        long nextId = ((timestamp - twepoch) << timestampLeftShift)
                | (datacenterId << datacenterIdShift)
                | (workerId << workerIdShift) | sequence;

        return nextId;
    }

    private long tilNextMillis(final long lastTimestamp) {
        long timestamp = this.timeGen();
        while (timestamp <= lastTimestamp) {
            timestamp = this.timeGen();
        }
        return timestamp;
    }

    private long timeGen() {
        return System.currentTimeMillis();
    }

    /**
     * <p>
     * 获取 maxWorkerId
     * </p>
     */
    protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) {
        StringBuffer mpid = new StringBuffer();
        mpid.append(datacenterId);
        String name = ManagementFactory.getRuntimeMXBean().getName();
        if (!name.isEmpty()) {
         /*
          * GET jvmPid
          */
            mpid.append(name.split("@")[0]);
        }
      /*
       * MAC + PID 的 hashcode 获取16个低位
       */
        return (mpid.toString().hashCode() & 0xffff) % (maxWorkerId + 1);
    }

    /**
     * <p>
     * 数据标识id部分
     * </p>
     */
    protected static long getDatacenterId(long maxDatacenterId) {
        long id = 0L;
        try {
            InetAddress ip = InetAddress.getLocalHost();
            NetworkInterface network = NetworkInterface.getByInetAddress(ip);
            if (network == null) {
                id = 1L;
            } else {
                byte[] mac = network.getHardwareAddress();
                id = ((0x000000FF & (long) mac[mac.length - 1])
                        | (0x0000FF00 & (((long) mac[mac.length - 2]) << 8))) >> 6;
                id = id % (maxDatacenterId + 1);
            }
        } catch (Exception e) {
            System.out.println(" getDatacenterId: " + e.getMessage());
        }
        return id;
    }
}
```

##### ⑤ MD5加密

utils.MD5Util.java中实现了MD5加密算法。

```java
public class MD5Util {
    private static String byteArrayToHexString(byte b[]) {
        StringBuffer resultSb = new StringBuffer();
        for (int i = 0; i < b.length; i++)
            resultSb.append(byteToHexString(b[i]));

        return resultSb.toString();
    }

    private static String byteToHexString(byte b) {
        int n = b;
        if (n < 0)
            n += 256;
        int d1 = n / 16;
        int d2 = n % 16;
        return hexDigits[d1] + hexDigits[d2];
    }

    public static String MD5Encode(String origin, String charsetname) {
        String resultString = null;
        try {
            resultString = new String(origin);
            MessageDigest md = MessageDigest.getInstance("MD5");
            if (charsetname == null || "".equals(charsetname))
                resultString = byteArrayToHexString(md.digest(resultString
                        .getBytes()));
            else
                resultString = byteArrayToHexString(md.digest(resultString
                        .getBytes(charsetname)));
        } catch (Exception exception) {
        }
        return resultString;
    }

    private static final String hexDigits[] = {"0", "1", "2", "3", "4", "5",
            "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"};


    public static void main(String[] args) {
        MD5Util md5Util = new MD5Util();
        String s = md5Util.MD5Encode("123", "UTF-8");
        System.out.println(s);//202cb962ac59075b964b07152d234b70
    }
}
```



#### 数据库设计

##### 数据库物理结构关联图

![1673617447342](报告.assets/1673617447342.png)

##### 数据表结构详细设计

用户（User）

| 序号 | 列名     | 数据类型 | 长度 | 键值 | 允许空 | 说明         |
| ---- | -------- | -------- | ---- | ---- | ------ | ------------ |
| 1    | userId   | int      |      | 主键 | 否     | 用户ID，自增 |
| 2    | userName | varchar  | 20   |      | 否     | 用户名       |
| 3    | password | varchar  | 30   |      | 否     | 密码         |

产品（Product）

| 序号 | 列名                | 数据类型 | 长度 | 键值 | 允许空 | 说明         |
| ---- | ------------------- | -------- | ---- | ---- | ------ | ------------ |
| 1    | productId           | int      |      | 主键 | 否     | 产品ID，自增 |
| 2    | productName         | varchar  | 20   |      | 否     | 产品名称     |
| 3    | categoryId          | int      |      | 外键 | 是     | 类型ID       |
| 4    | productTitle        | varchar  | 20   |      | 是     | 产品标题     |
| 5    | productPicture      | varchar  | 100  |      | 是     | 产品图片路径 |
| 6    | productPrice        | double   |      |      | 否     | 产品价格     |
| 7    | productSellingPrice | double   |      |      | 否     | 产品售价     |
| 8    | productNum          | int      |      |      | 否     | 产品数量     |
| 9    | productSales        | int      |      |      | 否     | 产品销量     |
| 10   | productIntro        | varchar  | 200  |      | 是     | 产品简介     |

产品类型（Category）

| 序号 | 列名         | 数据类型 | 长度 | 键值 | 允许空 | 说明     |
| ---- | ------------ | -------- | ---- | ---- | ------ | -------- |
| 1    | categoryId   | int      |      | 主键 | 否     | 类型ID   |
| 2    | categoryName | varchar  | 20   |      | 否     | 类型名称 |

购物车（ShoppingCart）

| 序号 | 列名      | 数据类型 | 长度 | 键值 | 允许空 | 说明     |
| ---- | --------- | -------- | ---- | ---- | ------ | -------- |
| 1    | id        | int      |      | 主键 | 否     | 购物车ID |
| 2    | productId | int      |      | 外键 | 否     | 产品ID   |
| 3    | userId    | int      |      | 外键 | 否     | 用户ID   |
| 4    | num       | int      |      |      | 否     | 购买数量 |

收藏（Collect）

| 序号 | 列名        | 数据类型 | 长度 | 键值 | 允许空 | 说明     |
| ---- | ----------- | -------- | ---- | ---- | ------ | -------- |
| 1    | id          | int      |      | 主键 | 否     | 收藏ID   |
| 2    | productId   | int      |      | 外键 | 否     | 产品ID   |
| 3    | userId      | int      |      | 外键 | 否     | 用户ID   |
| 4    | collectTime | int      | 64   |      | 否     | 收藏时间 |

订单（Order）

| 序号 | 列名         | 数据类型 | 长度 | 键值 | 允许空 | 说明     |
| ---- | ------------ | -------- | ---- | ---- | ------ | -------- |
| 1    | id           | int      |      | 主键 | 否     | 订单ID   |
| 2    | productId    | int      |      | 外键 | 否     | 产品ID   |
| 3    | userId       | int      |      | 外键 | 否     | 用户ID   |
| 4    | orderId      | varchar  | 20   |      | 否     | 订单号   |
| 5    | productNum   | int      |      |      | 否     | 购买数量 |
| 6    | productPrice | double   |      |      | 否     | 产品单价 |
| 7    | orderTime    | int      | 64   |      | 否     | 订餐时间 |

轮播图（Carousel）

| 序号 | 列名       | 数据类型 | 长度 | 键值 | 允许空 | 说明         |
| ---- | ---------- | -------- | ---- | ---- | ------ | ------------ |
| 1    | carouselId | int      |      | 主键 | 否     | 轮播ID       |
| 2    | imgPath    | varchar  | 100  |      | 是     | 图片路径     |
| 3    | describes  | varchar  | 100  |      | 是     | 推广内容描述 |



## 六、成员分工

### 前端成员

组长 欧骐华 20331029：完成网站头部、尾部导航栏、商品总览页面、登录页面、餐车页面、订单确认页面设计；回到最上方小组件实现；部分界面路由封装；部分api接口设计及实现；vuex子模块管理设计；撰写项目报告前端部分及整合完善。

李颖欣 20331020：实现广告页(首页)设计、网上订餐页面设计、摇摇机页面(外星页面)设计、部分其他页面修改；Mock数据编写进行接口测试；部分界面路由封装；部分api接口设计及实现；vuex子模块管理设计；撰写项目报告前端部分及整合完善。

### 后端成员

叶晓 20331043：实现用户、产品等部分的接口、实现部分业务逻辑、撰写项目报告后端部分及接口需求。

张境宏 20331046：实现购物车、下单等部分的接口、实现部分业务逻辑、撰写项目报告后端部分及接口需求。

孔浩楷 20331017：完成数据库设计，撰写项目报告后端部分。